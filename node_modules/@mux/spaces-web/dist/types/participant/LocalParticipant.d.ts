/// <reference types="node" />
import { LocalTrack } from '../track/LocalTrack';
import { CreateLocalMediaOptions } from './options';
import { EventEmitter } from 'events';
import { ParticipantRole } from './enums';
/**
 * A LocalParticipant is the local peer connected to the space.
 * Local participants can emit [[ParticipantEvent]] to allow you to respond
 * to state updates.
 *
 * @noInheritDoc
 */
export default class LocalParticipant extends EventEmitter {
    /**
     * The unique participant id derived from the `participant_id`
     * field in the JWT
     */
    id: string;
    /**
     * A unique connection id generated every time a participant connects
     * to a space
     */
    connectionId: string;
    private manager;
    /**
     * A map of all audio tracks on this participant
     */
    audioTracks: Map<string, LocalTrack>;
    /**
     * A map of all video tracks on this participant
     */
    videoTracks: Map<string, LocalTrack>;
    /**
     * The role for this participant in the space. This can be specified by the `role` field in the JWT.
     * If none is specificed, the default is [[ParticipantRole.Publisher]]
     */
    role: ParticipantRole;
    /**
     * publishTracks publishes an array of {@link LocalTrack} to
     * the space
     * @param tracks
     * @returns
     */
    publishTracks(tracks: LocalTrack[]): Promise<LocalTrack[]>;
    /**
     * updateTracks updates an array of {@link LocalTrack} based on
     * {@link TrackSource}. This replaces the underlying media being sent
     * to the space without the need to unpublish and republish tracks. This should
     * be used with {@link getDisplayMedia} to update a camera or microphone input.
     *
     * **Note:** If you pass a track source that isn't already published it will not be updated.
     * For example, say you are publishing a Camera source but not a Microphone source. If
     * you pass in a track with a source of [[TrackSource.Microphone]] nothing will happen.
     *
     * @param tracks
     * @returns all LocalTracks that were sucessfully updated
     */
    updateTracks(tracks: LocalTrack[]): LocalTrack[];
    /**
     * unpublishAllTracks unpublishes all media for a {@link LocalParticipant}
     */
    unpublishAllTracks(): Promise<void>;
    /**
     * unpublishTracks unpublishes a list of tracks from the space
     * @param tracks
     * @returns
     */
    unpublishTracks(tracks: LocalTrack[]): void;
    /**
     * getVideoTracks returns all video tracks
     * for a participant
     *
     * @returns
     */
    getVideoTracks(): LocalTrack[];
    /**
     * getAudioTracks returns all audio tracks
     * for a participant
     *
     * @returns
     */
    getAudioTracks(): LocalTrack[];
    /**
     * getUserMedia is a wrapper around the native
     * [`navigator.MediaDevices.getUserMedia`](https://developer.mozilla.org/docs/Web/API/MediaDevices/getUserMedia)
     * function. We do this in order to constrain video quality
     * to a reasonable default and return {@link LocalTrack} instances.
     *
     * @param options
     */
    getUserMedia(options?: CreateLocalMediaOptions): Promise<LocalTrack[]>;
    getDisplayMedia(options?: CreateLocalMediaOptions): Promise<LocalTrack[]>;
    private hasLocalTrack;
    private addLocalTrack;
    private validateVideoConstraints;
    /**
     * Updates existing track
     *
     * @param track
     *
     * @returns the track if update undefined otherwise
     */
    private updateTrack;
    private removeLocalTrack;
    private onMute;
    private onUnmute;
    private applyTrackOptions;
    private localTrackFromMediaTrack;
}
